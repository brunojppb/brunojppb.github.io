<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    
    
    
    
    
    
    
    <meta name="author" content="Bruno Paulino">
    <meta name="description" content="Why a monorepo can be the best way for scaling your teams">
    <meta name="keywords" content="monorepo,typescript,javascript,turborepo,scale,teams,dx">
    <meta name="theme-color" content="#21364B">
    
    <!-- Open Graph meta properties for beautifully rendering link previews on social -->
    <!-- See: https://ogp.me/ -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://bpaulino.com/entries/typescript-monorepo-series-what-is-a-monorepo" />
    <meta property="og:title" content="The TypeScript Monorepo Series" />
    <meta property="og:description" content="Why a monorepo can be the best way for scaling your teams" />
    <meta property="og:image" content="https://bpaulino.com/assets/images/posts/2022-08-28-ts-monorepo-series-part-1.jpg" />

    <!-- twitter card tags additive to og: meta properties -->
    <!-- See: https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/markup -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:domain" content="bpaulino.com" />
    <meta name="twitter:title" content="The TypeScript Monorepo Series" />
    <meta name="twitter:description" content="Why a monorepo can be the best way for scaling your teams" />
    <meta name="twitter:image" content="https://bpaulino.com/assets/images/posts/2022-08-28-ts-monorepo-series-part-1.jpg" />
    <meta name="twitter:url" content="https://bpaulino.com/entries/typescript-monorepo-series-what-is-a-monorepo" />
    <meta name="twitter:creator" content="@bpaulino0" />
    <meta name="twitter:label1" content="Created by" />
    <meta name="twitter:data1" content="Bruno Paulino" />
    <meta name="twitter:label2" content="Twitter" />
    <meta name="twitter:data2" content="@bpaulino0" />
    
    
    <link rel="shortcut icon" href="/assets/favicon/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">
    <title>The TypeScript Monorepo Series</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800&display=swap" rel="stylesheet">
    <!-- Timestamp from jekyll build to make sure the latest version is loaded correctly on our lovely readers' clients -->
    <link rel="stylesheet" href="/assets/css/styles.css?v=1665087387">
  </head>
  <body>

    <div role="main" class="main-container">

        <div class="main-header">
  <a href="/">
    <h2>bpaulino.com</h2>
  </a>
  <p>
    Hi, I am Bruno Paulino.<br />
    Software is my craft.
  </p>
  <nav>
    <a href="/">Blog</a>
    <a href="/about">About</a>
    <a href="/courses">Courses</a>
    <!-- <a href="/speaking">Speaking</a> -->
    <a href="/reading">Reading</a>
  </nav>
  <canvas class="particles-canvas"></canvas>
</div>


        <div class="flex-wrapper">
            <div class="max-width-wrapper">
                <div class="entry-container">
    <div class="entry">
        <h1 class="entry-title">The TypeScript Monorepo Series</h1>
        <div style="text-align: center; font-style: italic;">August 28, 2022</div>
    	<p>Welcome to the TypeScript monorepo article series. In this series, you will
learn about what a monorepo is, why it’s becoming so popular today and how you
can build your own production-ready monorepo with a Web application, a
documentation website and a component library, all built with
<a href="https://www.typescriptlang.org/">TypeScript</a>.</p>

<p>If you are working on a small and isolated app, chances are that you probably
don’t need a monorepo, but if you are building several different apps and small
libraries that somehow are related or dependent on each other, specially if you
are working on a large team, a monorepo is most probably the best strategy to
organize your code. It will make your code much closer to the engineers working
on them and will give your team a great productivity boost in the short and
long-run by sharing common standards.</p>

<p>So bear with me and let’s do a deep dive into monorepos by creating a rock-solid
version of it that you and your team is going to love to use. By the end of this
series, you will have a complete TypeScript monorepo template to start your
projects with the right foot, including dependency management, CI/CD with
parallel task execution and caching to avoid unnecessary work, testing
pipelines, commit strategy that drives automated releases with automatic
changelog generation.</p>

<h2 id="but-what-is-a-monorepo-anyways">But what is a monorepo anyways?</h2>

<p>Before jumping to definitions, let’s take a step back and understand how teams
usually go about creating new software projects and how they manage their
codebases.</p>

<p>Teams across the globe need a way to share code. And the <em>de facto</em> standard is
<a href="https://git-scm.com/">Git</a>. Along this series, we will create a git repo for a
hypothetical use-case where we need a Web app while we discuss the challenges
that a team might face along the way.</p>

<p>When starting out, you usually create a git repository offline on your machine
and eventually you share your code with your team using the platform of your
choice, the most popular being <a href="https://github.com/">Github.</a> This repository is
usually the house of your app. It’s where it lives your business logic, build
and deployment pipelines, automated tests (hopefully) and the history of your
changes.</p>

<p>When starting a new project, you usually do the following:</p>

<ul>
  <li>Create a new Git repo</li>
  <li>Setup your project from scratch or based on a template with build, test and
deployment pipelines</li>
  <li>Configure tools to help you with your development workflow, for instance a dev
server.</li>
</ul>

<p>Once the initial setup is done, you go about your work building your Web app for
your users.</p>

<h3 id="now-we-need-a-component-library">Now we need a component library</h3>

<p>Things are all good and fine, but now your team needs to build a component
library with common standards like buttons, colors, spacing, fonts and all the
visual identity of your brand because your product team needs a new Web app to
manage its customers and one of the requirements is that it must look and feel
like your current one.</p>

<p>This component library uses the same technologies you are using to build your
Web app like TypeScript and a very similar, but different, build pipeline. So to
start working on this new component library, you usually have two choices:</p>

<ol>
  <li>Build the component library as a subdirectory of your app, just like any
other shared module.</li>
  <li>Decouple your component library from your app in a separate repository so
engineers can work independently on both the App and the Component library.</li>
</ol>

<p>Let’s break these options down and explore their trade-offs next.</p>

<h4 id="option-1-building-as-a-subdirectory">Option 1: Building as a subdirectory</h4>

<p>Building the new component library within our existing Web app has clear
advantages:</p>

<ul>
  <li>
    <p><strong>Your entire setup is already in place.</strong></p>

    <ul>
      <li>You can start creating your component library right away and make use of
your testing and build pipelines. Your Web app can use these components with
no ceremony.</li>
    </ul>
  </li>
  <li>
    <p><strong>Team collaboration is high</strong></p>
    <ul>
      <li>Having the team working on the Web app and Component library all together
under the same repo will be a lot easier for collaboration. They can review
each other’s PRs, quickly test changes locally without extra setup and share
the same standards, significantly reducing mental overhead.</li>
    </ul>
  </li>
</ul>

<p>But there are a few drawbacks with this approach:</p>

<ul>
  <li><strong>You cannot version your components.</strong>
    <ul>
      <li>Which means that if you make a breaking change on your Button component,
your entire Web app needs to be changed in one go, otherwise you will not be
able to build your app.</li>
    </ul>
  </li>
  <li><strong>nobody else can use your component library.</strong>
    <ul>
      <li>Eventually, you might need to build an internal Web app to manage your
customers and ideally this internal Web app could have the same visual
identity as your public app. But given the Component library is tightly
coupled with your Web app, you can’t easily share your components outside of
your repo. Copy/paste is no fun.</li>
    </ul>
  </li>
</ul>

<h4 id="option-2-creating-a-new-repository">Option 2: Creating a new repository</h4>

<p>If the trade-offs of option 1 are not acceptable, you need an alternative way,
so the usual route taken by most teams is to go and create a new repository and
make your component library an independent package. This approach has several
benefits:</p>

<ul>
  <li>
    <p><strong>You can version your components</strong></p>

    <ul>
      <li>You can now make breaking changes to your components and as long as you
publish different versions of your library to a registry like
<a href="https://www.npmjs.com/">npm</a>, consumers of your component library can
remain safe until they decide to upgrade to the newest version of your
component library.</li>
    </ul>
  </li>
  <li>
    <p><strong>More than one app can use your components</strong></p>
    <ul>
      <li>Since you now publish your component library as an independent package,
other apps can now use it just as any other library out there. They can
quickly run <code class="language-plaintext highlighter-rouge">npm install @acme/components</code> and be ready to go.</li>
    </ul>
  </li>
</ul>

<p>But like any architecture choices, there are trade-offs we must consider:</p>

<ul>
  <li>
    <p><strong>You can no longer make sure that your app is using the latest version of
your components</strong></p>

    <ul>
      <li>This might be a desired side-effect, so you can actually let you team adopt
the new versions of your component library in an incremental way. On the
other hand, if you don’t prioritize library upgrades, the change drift of
what you have on your Web app and the newest version of your component
library might be so large that upgrading can become a nightmare.</li>
    </ul>
  </li>
  <li>
    <p><strong>You now have two codebases to worry about</strong></p>

    <ul>
      <li>Let’s face it, setting up a project from the ground up, with all it’s build,
test and deployment pipelines in a way that is ready for production and with
great developer experience takes time. Now you have two repositories to keep
dependencies and pipelines all updated and secure. This can become a major
mental overhead for your team, specially if you cannot afford to have a
dedicated team member or a platform team to support you with these tasks.
Your Web app and Component library repositories will grow apart and they
will eventually have divergent standards. Questions like “Which version of
TypeScript we are using?” or “Which Node version we are using now?” will get
harder to answer and even harder to make sure that everyone is at the same
page.</li>
    </ul>
  </li>
  <li>
    <p><strong>Engineers cannot collaborate in the same codebase anymore</strong></p>
    <ul>
      <li>You now have two independent codebases where engineers need to implement new
features, make changes, review pull-requests and push code to production.
But now they are far apart in two different repositories, which means that
engineers cannot review changes in a single place anymore. If they want to
checkout these changes locally, they will need to have the repositories all
setup locally and if it’s their first time working on the component library,
they might need to prepare their local environment from scratch to be able
to run and explore the code.</li>
    </ul>
  </li>
</ul>

<h2 id="but-what-is-the-alternative">But what is the alternative?</h2>

<p>With all the being said, there are plenty of trade-offs here that might be hard
to reach to a compromise. Both options 1 and 2 mentioned above are perfectly
reasonable, but it will really depend on the context you are working with.</p>

<p>The example given here is small in context, we are only considering a Web app
and a component library. What if you are part of a larger organization, with
dozens of engineers working on several different apps, component libraries and
other smaller libraries that need to be shared across all these apps?</p>

<h3 id="a-monorepo-might-be-your-best-choice">A monorepo might be your best choice</h3>

<p>What if I told you that there was a way to keep all your apps and libraries
under the same git repository and still keep them isolated from each other,
behaving just like libraries, but with all the benefits of working under the
same repo?</p>

<p>This is what a <strong>monorepo</strong> is. A set of tools and practices that allow you to
work under the same repository, but still be able to leverage module isolation
and team autonomy.</p>

<p>In the JavaScript/TypeScript ecosystem, this is possible due to a native feature
called <a href="https://pnpm.io/workspaces">workspaces</a> which allows us to manage
independent packages nested under a top-level root package. You will see that
applied in practice during this series, but this subtle difference has a huge
difference:</p>

<ul>
  <li>
    <p><strong>Your team can now work together in the same repo</strong></p>

    <ul>
      <li>Which means that working across different apps and libraries is just
transparent. No need to clone a different repo, check Node and package
manager version or anything that could drift apart in your tech stack and
standards. With a monorepo, we can guarantee that all apps and libraries are
using the exact same version of every dependency.</li>
    </ul>
  </li>
  <li>
    <p><strong>Module-level isolation with libraries versioned and published individually</strong></p>
    <ul>
      <li>Given that packages are isolated, you can still work on them individually,
making changes and publishing new versions to npm as you need. For packages
that contain applications that require a deployment step to some cloud
environment, it can be handled in the exact same way libraries are
published, just with a different deployment workflow. You will see that
being applied during this series.</li>
    </ul>
  </li>
</ul>

<p>With that being said, a monorepo isn’t a
<a href="http://worrydream.com/refs/Brooks-NoSilverBullet.pdf">silver bullet</a>. It does
come with challenges and we will talk about them as we start building our
monorepo example.</p>

<h2 id="what-is-next">What is next</h2>

<p>In the next article, we will start by creating our monorepo from scratch,
setting up a Web app, a Component library and a Documentation website. All of
them will be fully independent within their own packages and we will be able to
build, test and deploy them independently.</p>

<p>Stay tuned for the next blogpost.</p>

    </div>
    <script src="/assets/js/prism.js"></script>
    <script>
    	Prism.highlightAll();
    </script>
</div>

<div id="progress-bar"></div>
            </div>
        </div>

        <footer class="main-footer fixed-bottom">
    <div class="follow-container">
        <p>
            Get in touch via <a href="https://twitter.com/bpaulino0">Twitter</a>
            / follow my <a href="/feed.xml">RSS Feed.</a>
        </p>

        <span>
            © 2022 Bruno Paulino | <a style="font-size: 12px;" href="https://github.com/brunojppb/brunojppb.github.io">This website is open-source</a>
        </span> 
    </div>
</footer>

    </div>

    <!-- Full-screen image presentation -->
    <div class="fullscreen-overlay" style="display: none;">
        <button class="close-overlay">close</button>
    </div>

    <!-- Night/Light mode switch -->
    <button id="theme-switcher" 
            aria-label="Toggle theme" 
            title="Toggle theme" 
            data-light-asset="/assets/images/sun.svg"
            data-dark-asset="/assets/images/moon.svg">
    </button>


    <!-- Minimal Blog scripts -->
    <script src="/assets/js/blog.js?v=1665087387"></script>

    <!-- Privacy-first Analytics -->
    <script data-goatcounter="https://bpaulino.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
  </body>
</html>